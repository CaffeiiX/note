> 主要内容：程序如何与硬件交互，程序如何与特定系统软件中的软件交互


![[Pasted image 20230201231121.png]]

为什么采用分离编译的方式
1. 模块化：将代码分解成模块化部分
2. 效率：更改一个模块的时候，不需要重新编译所有模块，节省时间和空间
## 1. 静态链接
链接器做了什么
1. 符号解析
```C
void swap(); /**定义swap符号**/
swap(); /**引用符号**/
```
汇编器将符号定义存储在目标文件中，符号表中均为结构数组，包括了符号的相关信息。
符号解析即在链接过程中，将符号引用与符号定义相关联。

2. 重定位
将所有模块进行合并，每个符号、函数、变量存储在什么位置，这个方式即为重定位。编译器和汇编器生成重地址0开始的代码和数据节。链接器对每个符号的定义和具体的内存位置进行关联，修改符号的引用，让符号指向内存位置。

## 2. 目标文件
.o文件可重定位目标模块，汇编器的输出，不能加载入内存。
.a.out 可执行目标文件，链接器输出的文件，可以直接复制到内存并执行
.so 文件，共享目标文件，可在加载或者运行时，被动态地加载进内存并链接

上述所有文件都是通过ELF（可执行可连接格式）进行存储
## 3. 可重定位目标文件
![[Pasted image 20230201232802.png]]
.text 已编译程序的机器代码
.rodata 只读数据，`printf`语句中的格式串和开关语句的跳转表
.data 已初始化的全局和静态C变量
.bss 未初始化的全局和静态C变量，以及所有呗初始化为0的全局或静态变量。
- 注：局部变量存储于栈中，不保存在上述节中
.symtab 符号表，存在在程序中定义和应用的函数和全局变量的信息。
.rel.text 一个.text节中的位置的列表，当文件进行组合的时候需要修改位置
.rel.data 被模块引用或定义的所有全局变量的重定位信息
.debug 一个调试符号表，程序中定义的局部变量和类型定义，程序中定义和引用的全部变量，-g才会得到该表
.line 原始C源程序中的行号和.text节中机器指令之间的映射，-g才会得到该表
.strtab 一个字符串表，内容包括.symtab和.debug节中的符号表，以及节头部中的节名字，以`null`为结尾的字符串的序列
## 4 符号和符号表
- 由模块m定义并能被其它模块引用的全局符号，包括非静态的C函数和全局变量
- 由其它模块定义并被模块m引用的全局服啊后，被称为外部符号
- 由模块m定义和应用的局部符号，对应于带`static`属性的C函数和全局变量

符号表包含一个条目的格式如下：
```C
typedef struct {
	int name;         //字符串表中的字符偏移
	char type: 4,     //函数或者数据
		 binding: 4;  //表示符号是本地还是全局的
	char reserved;
	short section;    //节头部表的索引 
	long value;       //value是距定义目标的节的起始位置的偏移
	long size;
} Elf64_Symbol;
```
`section` 字段，也是一个到节头部表的索引，有三个特殊的伪节
- `ABS`代表不该被重定位的符号
- `UNDEF`代表未定义的符号
- `COMMON`表示还未被分配位置的未初始化的数据目标
区别：
`COMMON` 未初始化的全局变量
`.bss` 未初始化的静态变量，以及初始化为0的全局或静态变量
![[Pasted image 20230203004330.png]]
如图`main`符号是偏移量为0的24字节函数，且位于`text`节中，`Ndx = 1`代表`text`节
### 5 符号解析
链接器解析符号的方法是将每个引用与它可输入的可重定位目标文件的符号表中的一个确定的符号定义关联起来。
#### 5.1 多重定义的全局符号解析
1. 对于局部符号的引用
由于局部符号都具有唯一性，所以对局部符号的解析不存在问题
2.  对于全局符号的引用
对于全局符号的引用，首先需要区分强符号和弱符号
**强符号**：初始化的全局变量和函数
**弱符号**：未初始化的全局变量
- 不允许有多个同名的强符号
- 一个强符号和多个弱符号，选择强符号
- 多个弱符号，任意选择一个
#### 5.2 与静态库连接
编译系统提供一个中机制，将所有相关的目标模块打包成一个单独的模块，被称为**静态库**，可以作为链接器的输入。
静态库中，相关的函数会被编译成独立的目标模块，然后封装到一个单独的静态库文件中，在链接的时候，链接器会只复制被程序应用的目标模块。
静态库以一种以称为承当的特殊文件格式存放在磁盘中，存档文件的后缀为.a
`gcc -static -o prog2c main2.0 /.libvector.a`
其中完全链接的可执行文件代表了可加载到内存中并运行，在加载的时候无需更进一步的链接。
![[Pasted image 20230205010310.png]]
如上述main2文件中仅调用了`libvector.a`中的`addvec`的函数，所以仅对改函数涉及的模块进行复制。
#### 5.3 链接器如何使用静态库来解析引用
符号解析阶段，链接器维护三个集合：
1. 可重定位目标文件集合$E$，该文件集合最终会被合并称为可执行文件
2. 未解析的符号集合$U$，引用了但是尚未定义的符号
3. 输入文件中已定义的符号集合$D$
具体的流程如下
1. 判断命令行中的输入文件类型，如果是目标文件，则将该文件添加到$E$，修改$U D$集合
2. 如果文件是存档文件，此时链接器会尝试匹配存档$U$的符号和存档文件中定义的符号，如果文件出成员$m$匹配上，则将$m$添加到$E$中，同时修改$U D$
3. 对上述命令执行完毕后，如果$U$为非空集合，则链接器报错
### 6 重定位
重定位是指合并输入模块，同时为每个符号分配运行时地址。
- 重定义节和符号定义
将相同类型的节合并为同一类型的新的聚合节，然后将运行时内存地址赋给新的聚合节，付给输入模块定义的每一个节，以及赋给输入模块定义的每个符号。从而每条指令和全局变量都有唯一的运行时内存地址
- 重定义节中的符号引用
修改代码节和数据节中对每个符号的引用，使他们指向正确的运行地址。
总的来说，重定位做了两件事情，一部分是对于所有符号的运行地址进行赋值，一部分是对于内部调用，如函数等，对该调用的地址进行赋值。
#### 重定位条目
重定位条目主要是针对生成目标模块时，不确定数据和代码最终将放在内存中的什么位置，所以不知道该模块应用的外部定义的函数变量的位置，所以需要生成一个重定位条目，使得在其合并成可执行文件的时候如何修改引用。
`.rel.text` 存放代码的重定位条目
`.rel.data` 已初始化数据的重定位条目
```C
typedef struct {
	long offset;   //需要被修改的引用的节偏移
	long type: 32, //定位类型
		 symbol: 32; //需要指向的服啊后
	long addend; //对被修改应用的值做偏移调整
} Elf64_Rela;
```
此处考虑两种最基本的重定位类型。
- `R_X86_64_PC32` 相对定位
- `R_X86_64_32` 绝对定位
**重定位算法**
![[Pasted image 20230207004722.png]]
示例程序，`main.o`反编译得到的结果如下
![[Pasted image 20230207004844.png]]
1. 重定位相对引用
```c
r.offset = 0xf
r.symbol = sum
r.type = R_X86_64_PC32
r.addend = -4
```
其中由于调用`sum`的偏移位置为`0xe`，同时指令`e8`占用一个字节，所以偏移为`0xf`
如果链接器确定
`ADDR(s) = ADDR(.text) = 0X4004d0`
`ADDR(r.symbol) = ADDR(sum) = 0x4004e8`

`refaddr = ADDR(s) + r.offset = 0x4004d0 + 0xf = 0x4004df`
根据相对定位算法
`*refptr = (unsigned) (ADDR(r.symbol)  + r.addend - refaddr) = 0x5`
重定位修改为
`4004de: e8 05 00 00 callq 4004e8 <sum>`
执行上述命令时，PC的值为`0x4004e3`
- 将PC压入栈中
- `PC <- PC + 0x5 = 0x4004e8`
2.  重定位绝对引用
```c
r.offset = 0xf
r.symbol = array
r.type = R_X86_64_32
r.addend = 0
```
若此时`ADDR(r.symbol) = ADDR(array) = 0x601018`
`*refptr = (unsigned) (ADDR(r.symbol)  + r.addend) = 0x601018`
重定位修改为
`4004d9: bf 18 10 60 00  mov $0x601018, %edi` (小端法)
### 7. 可执行目标文件
![[Pasted image 20230208004537.png]]
可执行文件的连续的片(chunk)被映射到连续的内存段。**程序头部表**描述这种映射关系
![[Pasted image 20230208004654.png]]
对于任何段`s`，链接器必须选择一个起始地址`vaddr`，使得
`vaddr mod align = off mod align`
### 8 加载可执行目标文件
![[Pasted image 20230208004918.png]]
代码段从`0x400000`开始，然后是数据段。接着是运行时堆，通过`malloc`向上增长。堆后的区域是为了共享模块保留，用户栈从$2^{48}-1$开始，向下增长，栈上为内核内存不可见。
### 9 动态链接共享库
采用静态库存在两部分问题
1. 当库更新的时候，需要了解到库的更新内容，然后进行显示的重新链接
2. 基本上所有的C程序都会使用标准函数，这部分的代码会被复制到所有运行进程的文本段中，浪费内存。
所以采用了**共享库**，共享库是一个目标模块，在运行或者加载时，可以加载到任意的内存地址，并和内存中的程序链接，该过程被称为动态链接，具体过程如下。
![[Pasted image 20230208005202.png]]
- 重定位`libc.so libvector.so`的文本和数据各到一个内存段
- 重定位`prog2l`中所有对于上述定义的符号的引用
### 10 从应用程序中加载和链接共享库

之前部分是讨论在应用程序被加载后执行前，动态链接器加载和链接共享库的情景。下面讨论在运行时要求动态链接器加载和链接共享库。
```C
#include <dlfcn.h>
void *dlopen(const char *filename, int flags);
//加载和链接共享库filename，返回句柄
//用带选项RTLD_GLOBAL选项打开了的库，会解析filename中的外部符号
//flags参数 1.RTLD_NOW 让链接器立即解析对外部符号的引用 2.RTLD_LAZY链接器在执行来自库中的代码的时候再进行解析。
void *dlsym(void *handle, char *symbol);
//根据共享库的句柄判断symbol是否存在
int dclose(void *handle);
//卸载共享库
const char *dlerror(void);
//发生错误时调用

// eg
int x[2] = {1,2};
int y[2] = {3,4};
int z[2];
int main(){
	void *handle;
	void (*addvec)(int*,int*,int*,int);
	char *error;
	handle = dlopen("./libvector.so", dlerror());
	if(!handle){
		fprintf(stderr, "%s\n", dlerror());
		exit(1);
	}
	addvec = dlsym(handle, "addvec");
	if((error = dlerror()) != NULL){
		fprintf(stderr, "%s\n", error);
		exit();
	}
	addvec(x,y,z,2);
	printf("z = [%d %d]\n", z[0],z[1]);
	if(dlclose(handle) < 0){
		fprintf(stderr, "%s\n", dlerror());
		exit(1);
	}
	return 0;
}
```
### 11 位置无关代码
共享库存在的一个问题：多个进程如何共享程序中的一个副本
解决方案1： 给每个共享库分配一个事先预备的专用的地址空间片，存在如下两个问题
- 即使进程不使用该库，但仍然需要预先设置该部分空间，内存利用率不高
- 当库需要更新的时候需要重新分配内存片，增大了对于库管理的复杂度。
所以采用了一种，将共享模块的代码段可以加载到内存的任何位置无需链接器修改，从而实现了多个进程一个共享一个共享模块的代码段的单一副本，该部分的代码称为**位置无关代码**
1. PIC数据引用
基于一个事实：**无论我们在内存的何处加载一个目标模块，数据段和代码段的距离总是保持不变，也就是指令和数据段之间的变量之间的距离是一个运行时常量**，简单的来说，由于代码段和数据段都是一段连续的内存，所以保证了运行时常量。
为此，在数据段开始的地方创建了一个表，称为全局偏移量表，该模块中的全局数据目标（过程或全局变量）都会有一个8字节条目，编译器会为该条目生成一个重定位记录，从而使其包含目标的正确的绝对地址。
![[Pasted image 20230209010255.png]]
2. PIC函数调用
如果程序调用由共享库定义的函数，所以无法定位该函数的运行时地址，一般的方法是为该应用生成一条重定向记录，然后动态链接器在程序加载的时候进行解析，但是该方法需要修改调用模块的代码段，并不是PIC，所以需要采用**延迟绑定**，将过程地址的绑定推迟到第一次调用该过程时。
![[Pasted image 20230209010745.png]]
初始化流程
1. 程序调用进入`PLT[2]`，这是`addvec`的`PLT`条目
2. 跳转到`GOT[4]`，由于`GOT[4]`初始化的地址指向`POL`的第二条指令，此处为`0x4005c6`
3. 将`addvec`的`ID(0x1)`压入栈中，跳转到`PLT[0]`
4. `PLT[0]`通过`GOT[1]`将动态链接器的一个参数压入栈中，然后通过`GOT[2]`跳入动态链接器中，此时栈中存在两个条目：函数ID和链接器参数，从而获取得到了`addvec`的运行地址，将上述地址重写`GOT[4]`，然后将控制传递给`addvec`
后续再次调用`addvec`的控制流
1. 程序调用进入`PLT[2]`，这是`addvec`的`PLT`条目
2. 跳转到`GOT[4]`，由于`GOT[4]`初始化的地址此时指向的是函数调用的地址，所以会直接将控制转移给`addvec`
### 12 库打桩机制
本质是`装饰器`的思路，即截获对共享库函数的调用，执行自己的代码，该方法可以最终某个库函数的调用次数等。
基本思路：对需要打桩的目标函数，通过包装函数对其进行包装，欺骗系统调用包装函数，在执行自己的操作后，在执行目标函数，将目标函数的返回值传递给调用者。
可以分为编译时、链接时、当程序被加载或执行的运行时三种。
```C
// int.c
#include<stdio.h>
#include<malloc.h>

int main(){
	int *p = malloc(32);
	free(p);
	return 0;
}
```
#### 编译时打桩
```
linux> gcc -DCOMPLIETIME -c mymalloc.c
linux> gcc -I. -o intc int.c mymalloc.o
```
`-I`参数，告诉C与处理器在搜索通常的系统目录之前，现在当前目录查找`malloc.h`，其中`mymalloc.c`中的包装函数是用`malloc.h`进行编译的
#### 链接时打桩
静态链接器支持用`--wrap f`标志进行链接时打桩，把对符号`f`的引用解析成`__wrap_f`，把对符号`__real_f`的引用解析为`f`
```C
// mymalloc.c
#ifdef LINKTIME
#include <stdio.h>
void *__real_malloc(size_t size);
void __real_free(void *ptr);

void *__wrap_malloc(size_t size){
	void *ptr = __real_malloc(size);
	printf("malloc(%d) = %p\n", (int)size, ptr);
	return ptr;
}
void __wrap_free(void *ptr){
	__real_free(ptr);
	printf("free(%p)\n", ptr);
}
```
`linux> gcc -DLINKTIME -c mymalloc.c`
`linux> gcc -c int.c`
`linux> gcc -Wl, --wrap,malloc -Wl, --wrap, free -o intl int.o mymalloc.o`

#### 运行时打桩
该机制基于动态链接器短的`LD_PRELOAD`环境变量，如果`LD_PRELOAD`环境变量被设置为一个共享库路径名的列表，那么当加载和执行一个程序，需要解析未定义的引用的时候，动态链接器会先搜索`LD_PRELOAD`库，基于此，可以对任何共享库的任何函数打桩。
`linux> gcc -DRUNTIME -shared -fpic -o mymalloc.so mymalloc.c -ldl`
`linux> gcc -o intr int.c`

运行时调用共享库的原因是参照 #10从应用程序中加载和链接共享库
由于是在应用程序加载后执行前，即运行时打桩，所以需要使用`dlsym`等函数

```C++
void *malloc(size_t size){
	void *(*mallocp)(size_t size);
	mallocp = dlsym(RTLD_NEXT, "malloc");
	if((error = dlerror()) != NULL){
		fputs(error, stderr);
		exit(1);
	}
	char *ptr = mallocp(size);
	printf("malloc(%d) = %p\n", int(size), ptr);
	return ptr;
}
void free(void *ptr){
	void *(*freep)(void *) = NULL;
	char *error;
	if(!ptr){
		return;
	}
	freep = dlsym(RTLD_NEXT, "free");
	if((error = dlerror()) != NULL){
		fputs(error, stderr);
		exit(1);
	}
	freep(ptr);
	printf("free(%p)\n", ptr);
}
```

运行程序如下
`LD_PRELOAD="./mymalloc.so" ./intr`