### 概念相关
- 控制转移： 对于$a_0, a_1,...,a_{n-1}$的序列而言，其中$a_k$是某个相应的指令$I_k$的地址，每次从$a_k$到$a_{k+1}$的过渡，这样的控制转义序列为控制流。
- 异常控制流（ECF）：对控制流发生突变的情况做出反应称为异常控制流
### 概述
一般的平滑序列的突变是通过对于跳转、调用返回等程序指令实现的，这是程序内部的状态变化关系。但系统必须对于**程序外**的一些状态的变化作出反应，这就需要程序对于控制流突变做出反应。
ECF的作用：
1. 理解重要的系统概念
2. 理解应用程序如何同操作系统进行交互
3. 操作系统为应用程序提供了ECF机制
4. 理解并发
5. 理解软件异常是如何工作的
### 异常
![[Pasted image 20230401161438.png]]
异常就是控制流中的突变，用来相应处理器状态中的某些变化。图中发生的状态变化（即事件），事件可能由指令引起（如算术溢出等），也可能是系统定时器等无关因素，当处理器检测到事件的发生时。
通过异常表的跳转表，进行一个间接过程调用，到处理相关事件的操作系统子程序（异常处理程序），处理结束后发生三种情况
1. 处理程序将控制返回给当前指令
2. 处理程序将控制返给下一条指令
3. 处理程序终止被中断的程序
#### 异常处理
- 异常表的生成
![[Pasted image 20230401162348.png]]
系统对每种类型的异常都分配了一个唯一的非负整数的*异常号*，包括两部分：处理器的设计者分配：零除、缺页、内存访问违例、断点、算术运算溢出。操作系统内核的设计值分配：系统调用、来自外部I/O设备的信号。
系统启动时会分配和初始化一张异常表
- 异常处理流程
![[Pasted image 20230401162828.png]]
发生事件后，处理器通过*异常表基址寄存器*来u而定异常号的地址
1. 过程调用时，跳转到异常处理程序前，处理器将返回地址压入栈中，该地址要么是当前指令要么是下一条指令
2. 处理器会将一些额外的处理器状态压入栈中，当异常处理程序返回时，程序重新执行需要上述状态
3. 如果控制从用户程序转移到内核，所有项目都被压入内核栈中
4. 异常处理程序运行在内核模式，这意味它对于所有的系统资源都有访问权限。
5. 异常处理程序处理完后，执行一条**从中断返回**指令，可选地的返回到被中断的程序，该指令将适当的状态弹回到处理器的控制和数据寄存器中，如果中断的是用户程序，将恢复到用户模式。
#### 异常类型
- 中断（异步）
此处的异步指的是，该中断同执行什么程序无关。
![[Pasted image 20230401163855.png]]
该中断是需要在当前指令完成后再进行。
- 陷阱
改中断方式是有意的异常，其最重要的作用在于给**用户态**的程序调用**内核态**相关功能的接口，**系统调用**。
用户程序需要向内核请求服务，如读文件、创建一个新的进程、加载一个新的程序、终止当前进程，处理器提供了一个指令 `syscall n`，请求服务`n`的时候可以调用该指令。
![[Pasted image 20230401164402.png]]
- 故障
故障是由于错误情况引起的，可能能够被故障处理程序修正，如果修正了继续执行当前指令了，否则终止当前程序。
![[Pasted image 20230401164553.png]]
如缺页异常，当指令引用的虚拟地址，当该地址对应的物理页面不在内存中，则会发生故障，而缺页异常程序从磁盘中加载适当的页面，此时可以将控制返回给当前指令。
- 终止
硬件错误，会将控制给`abort`例程，终止该应用程序。
### 进程
每个程序都运行在某个进程的上下文中，上下文是由程序正确运行所需的状态组成的，包括内存中的程序的代码和数据、栈、寄存器内容、程序计数器、环境变量以及打开文件描述符的集合。
- 一个独立的逻辑控制流，提供一个假象，程序独立的使用处理器
- 一个私有的地址空间，提供一个假象，程序独占使用内存系统。
#### 逻辑控制流
程序计数器值的序列称为逻辑控制流
![[Pasted image 20230401173459.png]]
从时间角度来说，进程之间是交替运行的，此处的关键在于如何轮流使用处理器。
#### 并发流
一个逻辑流的执行再时间上与另一个重叠，被称为并发流。
此处的并发并不是指同一时间上有多个进程运行，如上图AB为并发，BC不为并发。
如果两个流并行地运行在不同处理器核或者计算机上，称他们为**并行流**。
一个进程和其他进程轮流运行的概念被称为**多任务**，一个进程执行它地控制流地一部分的每个时间段叫做时间片。
#### 私有地址空间
进程为没个程序提供它自己的私有地址空间，该地址空间是不能被其它进程读或者写的。
![[Pasted image 20230401175758.png]]
地址空间底部是保留给用户程序的，地址空间顶部保留给内存。
#### 用户模式和内核模式
限制一个应用可以执行的指令以及它可以访问的地址空间范围，通过某个控制寄存器中的一个**模式位**（`mode bit`），描述了当前进程享有的特权，设置模式位运行在内核模式中，未设置则运行在用户模式中，用户模式不允许执行**特权指令（`privileged instruction`）**，如停止处理器、改变模式位、发起I/O操作等。
从用户模式变为内核模式的唯一方法是中断、故障等异常。linux提供了一种`/proc`文件系统，允许用户模式进程访问内核数据结构的内容，可以找到如一般的系统属性、某个进程使用的内存段等。
#### 上下文切换
内核为每个进程维持一个上下文，上下文就是内存重新启动一个被抢占的进程所需的状态，包括了通用目的寄存器、浮点寄存器、程序计数器、用户栈、状态寄存器、内核栈和各种内核数据结构等。
当进程执行的某些时刻，内核决定抢占当前进程，重新开始一个已经被抢占的进程，该决策即为**调度**，是由**调度器**的代码处理的。上下文切换过程
1. 保存当前进程的上下文
2. 恢复某个先前被抢占的进程被保存的上下文
3. 将控制传递给这个新恢复的进程
触发的条件
1. 内核执行系统调用的时候，如果一个read系统调用需要访问磁盘，内核可以进行上下文切换
2. 中断，系统判断当前进程是否执行足够长的时间，是的话会进行切换
![[Pasted image 20230401182310.png]]
#### 进程控制
```C
pid_t getpid(void); //返回进程的PID
pid_t getppid(void);//返回父进程的PID
```
创建和终止进程
- 运行
- 停止，进程的执行被挂起，当收到SIGSTOP、SIGTSTP、SIGTTIN或者SIGTTOUT信号的时候，进程停止，直到收到信号SIGCONT
- 终止：1）收到终止信号。2）从主程序返回，3）调用exit函数
- 创建：通过`fork()`函数，新创建的子进程得到与父进程用户级虚拟地址空间相同的一份副本，包括代码和数据段、堆、共享库以及用户栈（上述为副本，彼此独立），获取任何打开文件描述符相同的副本，即可以读写父进程中的任意文件。`fork()`会调用两次，父进程调用返回子进程的PID，子进程中返回0，可以通过此来判断是位于父进程还是子进程。
![[Pasted image 20230417235735.png]]
可以通过上述图判断可能执行的具体顺序。
- 回收：当一个进程由于某种原因终止时，直到被父进程回收已终止的子进程，内核将子进程的退出状态传递给父进程，一个终止但是未被回收的进程被称为僵死进程。如果父进程终止但是子进程未被回收，会安排`init`进程（PID=1，系统启动时内核创建）去回收子进程。
```c
pid_t watipid(pid_t pid, int *statusp, int options); //等待子进程终止或者停止
```
****
**options**
1. options = 0，默认情况下，挂起调用进程的执行，直到等待集合中的一个子进程终止，如果已经有一个进程已经终止则立即返回，返回已终止的子进程的PID。pid>0等待集合为一个单独的子进程，如果pid=-1,则等待集合为父进程的所有子进程
2. WNOHANG，如果等待集合中的任何子进程都未终止则返回0。
3. WUNTRACED，直到等待集合中的一个进程变成已终止或者被停止，返回该进程的PID。
4. WCONTINUED，直到等待集合中的一个正在运行的进程终止或者一个被停止的进程重新开始执行
****
**statusp**退出状态
如果statusp参数非空，waitpid会在statusp指向的status参数中放置状态信息。
![[Pasted image 20230418225507.png]]
****
进程休眠：`sleep()`返回已休眠的秒数
**加载并执行程序**
```C
int execve(char *filename, char *argv[], char *envp[])
/*
filename: #!interpreter
argv: eg. argv[0] == filename
envp: 环境变量
*/
// 仅仅会执行一次，并不会返回
// 出现错误的时候会返回到调用程序
```
![[Pasted image 20230418232507.png]]
argv/envp变量指向一个以null结尾的指针数组
![[Pasted image 20230418233000.png]]
`main`函数中
- `argc`，argv数组中非空指针的数量
- `argv`，指向数组中的第一个条目
- `envp`，指向envp数组中的第一个条目
****
**利用fork和execve运行程序**
即在子进程环境中运行execve，从而执行外部相关程序，如shell，对于输入的命令行参数等进行分割后生成子进程进行执行。
#### 信号
****
发送信号，主要有两种原因
1. 内核检测到一个系统事件，如除零错误或者子进程终止
2. 一个进程调用kill函数，显示地要求内核发送一个信号给目的进程
接受信号，进程被内核强迫对信号的发送做出反应
![[Pasted image 20230420231857.png]]
一个发送但是未被接收的信号被称为待处理信号，任何时刻一种类型至多会有一个待处理信号，后续出现相同类型的待处理信号会被丢弃。同样一个进程可以选择性的阻塞接收某种信号。
一个待处理信号最多被接收一次，每个进程中用`pending`向量维护待处理向量集合，`block`向量维护被阻塞信号的集合，当传送一个$k$信号的，会设置`pending`向量中的第$k$位，当接收一个$k$信号，内核会清除`pending`中的第$k$位
##### 发送信号
****
进程组：每个进程都只属于一个进程组，默认情况下子进程和父进程同属于一个进程组
```sh
/bin/kill -9 15213 发送信号9给进程15213 
```
从键盘发送信号
`linux> ls | sort`此时会创建一个由两个进程组成的前台作业，每个作业都有一个独立的进程组。
![[Pasted image 20230421213037.png]]

```C
int kill(pid_t pid, int sit);
// pid = 0则发送给进程组中的每个进程
// pid < 0则发送信号给进程组|pid|中的每个进程
unsigned int alarm(unsigned int secs);
// 在secs秒后发送SLGALRM给调用进程
```
##### 接收信号
内核模式 $\to$ 用户模式：检查进程中的未被阻塞的待处理信号的集合，如果为非空，则选择集合中的某个信号$k$，并且强制进程接收信号$k$，完成行为后会调用下一条指令
信号类型的默认行为包括了
- 进程终止
- 进程终止并转储内存
- 进程停止（挂起）直到被SIGCONT信号重启
- 进程忽略该信号
```C
sighanler_t singal(int signum, sighandler_t handler);
/**
作用：改变跟信号相关联的行为
handler:
SIG_IGN，忽略类型为signum的信号
SIG_DFL, 类型为该型号的恢复默认行为
用户定义函数的地址，该函数为信号处理程序
返回值为信号类型
**/
```
![[Pasted image 20230421215734.png]]
##### 阻塞和接触阻塞信号
隐式阻塞机制，内核默认阻塞任何当前处理程序正在处理类型的待处理信号，即当程序当捕获到信号时进行处理时，阻塞其它信号。
显式阻塞机制
```C
int sigprocmask(int how, const sigset_t *set , sigset_t *oldset);
/**
how
-SIG_BLOCK: 将set中的信号添加到blocked中
-SIG_UNBLOCK: 将blocked中删除set中的信号
-SIG_SETMASK：block=set
**/
// sigemptyset 设置set为空集合
// sigfillset  将每个信号都添加到set中
// sigaddset 将signum添加到set
// sigdelset 从set中删除signum
```
##### 编写信号处理程序
- 处理程序要尽可能简单
- 处理程序中只调用异步信号安全的函数
- 保存和恢复`errno`
- 阻塞所有的信号，保护对共享全局数据结构的访问
- `volatile`保存全局变量，告诉编译器不缓存改变量
- `sig_atomic_t`声明标志，对该标志的读写是原子的，通过该标志来判断是否收到了信号
#### 非本地跳转
```C
void setjmp(jum_buf env); //在env缓冲区保存环境
void sigsetjmp(sigjmp_buf env, int savesigs);
void longjmp(jmp_buf env, int retval); //从env缓冲区中恢复调用环境，然后触发setjmp的调用的返回。
```
从深层嵌套函数中的调用立刻返回。